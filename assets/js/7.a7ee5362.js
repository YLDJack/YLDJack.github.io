(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{430:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_1.d3bbcc97.png"},431:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_3.c7a5cdd0.png"},479:function(e,t,s){e.exports=s.p+"assets/img/vue3.0.6c66373f.png"},480:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_4.4c4bf43d.png"},481:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_5.5c743c1e.png"},482:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_6.9cae3503.png"},483:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_7.9c594861.png"},484:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_8.718dec0e.png"},485:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_9.04cd4061.png"},486:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_10.f56a10b8.png"},487:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_11.a5b39a82.png"},488:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_13.f268f159.png"},489:function(e,t,s){e.exports=s.p+"assets/img/vue3.0_14.7db7368a.png"},517:function(e,t,s){"use strict";s.r(t);var a=s(4),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("img",{attrs:{src:"/images/vue3.png",width:"100%",height:"100%"}})]),e._v(" "),a("h1",{attrs:{id:"vue3-0-beta笔记（侧重performance提升原因和composition-api）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-beta笔记（侧重performance提升原因和composition-api）"}},[e._v("#")]),e._v(" Vue3.0 Beta笔记（侧重Performance提升原因和Composition API）")]),e._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("p",[e._v("昨晚（北京时间2020年4月22日），Vue作者Evan You（尤雨溪）在前端圈的B站直播间分享了关于'Vue3.0 Beta'的一些新的特性和进展。（在此附附上掘金录播链接：https://juejin.im/e/vue-3）")]),e._v(" "),a("p",[e._v("本文，是个人记录的一些笔记，更关注与侧重Performance提升原因和Composition API，这两部分记录的比较详细，相当于是下方连接的一些补充，欢迎大家留言补充和探讨。")]),e._v(" "),a("p",[e._v("参考链接："),a("a",{attrs:{href:"https://juejin.im/post/5e9f6b3251882573a855cd52#heading-8",target:"_blank",rel:"noopener noreferrer"}},[e._v("抄笔记：尤雨溪在Vue3.0 Beta直播里聊到了这些…"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"一、rfcs（request-for-comments）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、rfcs（request-for-comments）"}},[e._v("#")]),e._v(" 一、RFCs（Request For Comments）")]),e._v(" "),a("p",[a("img",{attrs:{src:s(479),alt:"img"}})]),e._v(" "),a("blockquote",[a("p",[e._v("尤大在直播开头提到，所有的Vue3大的的改动都是通过 "),a("a",{attrs:{href:"https://github.com/vuejs/rfcs",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue3-RFCs GitHub"),a("OutboundLink")],1),e._v("仓库上和大家进行讨论，所有进度和改动细节都能在其中看到，不需要再获取别人的二手信息了。如果大家想要深入了解可以点击上面的连接。（PS：看的真的会很累，讨论地特别细。）")])]),e._v(" "),a("h2",{attrs:{id:"二、六大亮点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、六大亮点"}},[e._v("#")]),e._v(" 二、六大亮点")]),e._v(" "),a("p",[a("img",{attrs:{src:s(430),alt:"img"}})]),e._v(" "),a("ol",[a("li",[a("strong",[e._v("Performance")]),e._v("：性能更比"),a("code",[e._v("Vue 2.0")]),e._v("强。（update 性能提高1.3-2倍和ssr服务端渲染速度快2-3倍，基于bechmark）")]),e._v(" "),a("li",[e._v("**Tree shaking support：**可以将无用模块“剪枝”。")]),e._v(" "),a("li",[e._v("**Composition API：**组合"),a("code",[e._v("API")]),e._v("相对于"),a("code",[e._v("Vue2.x")]),e._v("的"),a("code",[e._v("Options API")]),e._v("（后面细讲）")]),e._v(" "),a("li",[a("strong",[e._v("Fragment, Teleport, Suspense")])]),e._v(" "),a("li",[e._v("**Better TypeScript support：**更优秀的Ts支持")]),e._v(" "),a("li",[e._v("**Custom Renderer API：**暴露了自定义渲染"),a("code",[e._v("API")])])]),e._v(" "),a("h3",{attrs:{id:"_1-performance提升的原因（视频中通过以下demo展示）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-performance提升的原因（视频中通过以下demo展示）"}},[e._v("#")]),e._v(" 1.Performance提升的原因（视频中通过以下Demo展示）")]),e._v(" "),a("blockquote",[a("p",[e._v("可以通过点击"),a("a",{attrs:{href:"https://vue-next-template-explorer.netlify.app/",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue-next-template-explorer"),a("OutboundLink")],1),e._v("进入视频中模板编制的Playgruond。其永远和vue3.0 github上master最新的commit保持一致")])]),e._v(" "),a("p",[a("strong",[e._v("（1）模板编译的优化")])]),e._v(" "),a("p",[a("img",{attrs:{src:s(430),alt:"img"}})]),e._v(" "),a("p",[e._v("代码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<div>\n  <span/>\n  <span>{{ msg }}</span>\n</div>\n")])])]),a("p",[e._v("将会被编译成以下模样：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from "vue"\n\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createBlock("div", null, [ \n    _createVNode("span", null, "static"),\n    _createVNode("span", null, _toDisplayString(_ctx.msg), 1 /* TEXT */)\n  ]))\n}\n\n// Check the console for the AST\n')])])]),a("p",[e._v("根结点"),a("code",[e._v("div")]),e._v("将会被编译成"),a("code",[e._v("Block")])]),e._v(" "),a("p",[e._v("动态绑定"),a("code",[e._v("msg")]),e._v("属性的"),a("code",[e._v("span")]),e._v("，编译后_createVNode会生成"),a("code",[e._v("PacthFlag")]),e._v("（相当于编译时生成一个hint），JS runtime在运行的时候，会知道"),a("code",[e._v("div")]),e._v("是一个"),a("code",[e._v("block")]),e._v("，只会对带有"),a("code",[e._v("PacthFlag")]),e._v("的结点进行真正的追踪。在真正的更新的时候，会直接跳到该结点，比较该结点文字的变化。不需要去关注其他属性和绑定的变化。")]),e._v(" "),a("h3",{attrs:{id:"patchflags枚举定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#patchflags枚举定义"}},[e._v("#")]),e._v(" PatchFlags枚举定义")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('export const enum PatchFlags {\n  \n  TEXT = 1,// 表示具有动态textContent的元素\n  CLASS = 1 << 1,  // 表示有动态Class的元素\n  STYLE = 1 << 2,  // 表示动态样式（静态如style="color: red"，也会提升至动态）\n  PROPS = 1 << 3,  // 表示具有非类/样式动态道具的元素。\n  FULL_PROPS = 1 << 4,  // 表示带有动态键的道具的元素，与上面三种相斥\n  HYDRATE_EVENTS = 1 << 5,  // 表示带有事件监听器的元素\n  STABLE_FRAGMENT = 1 << 6,   // 表示其子顺序不变的片段（没懂）。 \n  KEYED_FRAGMENT = 1 << 7, // 表示带有键控或部分键控子元素的片段。\n  UNKEYED_FRAGMENT = 1 << 8, // 表示带有无key绑定的片段\n  NEED_PATCH = 1 << 9,   // 表示只需要非属性补丁的元素，例如ref或hooks\n  DYNAMIC_SLOTS = 1 << 10,  // 表示具有动态插槽的元素\n  // 特殊 FLAGS -------------------------------------------------------------\n  HOISTED = -1,  // 特殊标志是负整数表示永远不会用作diff,只需检查 patchFlag === FLAG.\n  BAIL = -2 // 一个特殊的标志，指代差异算法（没懂）\n}\n')])])]),a("p",[e._v("更具体的例子：")]),e._v(" "),a("p",[e._v("加上一大堆的静态内容：")]),e._v(" "),a("p",[a("img",{attrs:{src:s(431),alt:"img"}})]),e._v(" "),a("p",[e._v("在默认的Diff的算法下，会把所有的静态的"),a("code",[e._v("span")]),e._v(" 都检查一遍，而且每个"),a("code",[e._v("span")]),e._v("都要看新的"),a("code",[e._v("Props")]),e._v("和旧的有没有变化，虽然说JS做这写效率很高，但是当所需要的更新的结点量很大时，不可避免地会浪费很多的时间。")]),e._v(" "),a("p",[e._v("在Vue 3.0的Diff的算法中，只需在Block中寻找带"),a("code",[e._v("PacthFlag")]),e._v("的结点，只要把这些结点检查一遍就行了，这样就解决的传统Diff算法中最耗时最浪费性能的部分。")]),e._v(" "),a("p",[a("img",{attrs:{src:s(431),alt:"img"}})]),e._v(" "),a("p",[a("strong",[e._v("无论层级嵌套多深，它的动态节点都直接与"),a("code",[e._v("Block")]),e._v("根节点绑定，无需再去遍历静态节点")])]),e._v(" "),a("p",[e._v("如果存在一个动态的绑定和静态绑定：")]),e._v(" "),a("p",[a("img",{attrs:{src:s(480),alt:"img"}})]),e._v(" "),a("p",[e._v("我们在Diff时，只会关注"),a("code",[e._v("id")]),e._v("是否变化，不会关注"),a("code",[e._v("class")]),e._v("的变化。")]),e._v(" "),a("p",[a("code",[e._v("PatchFlag")]),e._v(" 变成了"),a("code",[e._v('9 /* TEXT, PROPS */, ["id"]，')]),e._v("它会告知我们不光有"),a("code",[e._v("TEXT")]),e._v("变化，还有"),a("code",[e._v("PROPS")]),e._v("变化（id）")]),e._v(" "),a("p",[e._v("这样既跳出了"),a("code",[e._v("virtual dom")]),e._v("性能的瓶颈，又保留了可以手写"),a("code",[e._v("render")]),e._v("的灵活性。 等于是：既有"),a("code",[e._v("react")]),e._v("的灵活性，又有基于模板的性能保证。")]),e._v(" "),a("p",[e._v("**"),a("code",[e._v("react")]),e._v("是否能在JSX做这样的东西呢？**在简单的情况下可以做，因为"),a("code",[e._v("JSX")]),e._v("是"),a("code",[e._v("JS")]),e._v("的语法比模板本身的语法要灵活的多。")]),e._v(" "),a("p",[a("strong",[e._v("所说的简单的情况：")])]),e._v(" "),a("p",[e._v("hostStatic（把静态的结点提升）")]),e._v(" "),a("p",[a("img",{attrs:{src:s(481),alt:"img"}})]),e._v(" "),a("p",[e._v("静态的结点被拿到渲染函数外，在应用启动的时候被创建一次，这些虚拟结点就会在每次渲染的时候被复用。优化大型项目的内存占用，不用每次渲染都创建这些结点了。")]),e._v(" "),a("h3",{attrs:{id:"（2）-添加事件监听缓存：cachehandlers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（2）-添加事件监听缓存：cachehandlers"}},[e._v("#")]),e._v(" （2） 添加事件监听缓存：cacheHandlers")]),e._v(" "),a("p",[e._v("关闭"),a("code",[e._v("cacheHandlers")]),e._v("：")]),e._v(" "),a("p",[a("img",{attrs:{src:s(482),alt:"img"}})]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('export function render(_ctx, _cache) {\n  return (_openBlock(), _createBlock("div", null, [\n    _createVNode("span", { onClick: _ctx.onClick }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, ["onClick"])\n  ]))\n}\n')])])]),a("p",[e._v("开启"),a("code",[e._v("cacheHandlers")]),e._v("：")]),e._v(" "),a("p",[a("img",{attrs:{src:s(483),alt:"img"}})]),e._v(" "),a("p",[a("code",[e._v("cache[1]")]),e._v("，会自动生成并缓存一个内联函数，“神奇”的变为一个静态节点。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('export function render(_ctx, _cache) {\n  return (_openBlock(), _createBlock("div", null, [\n    _createVNode("span", {\n      onClick: _cache[1] || (_cache[1] = $event => (_ctx.onClick($event)))\n    }, _toDisplayString(_ctx.msg), 1 /* TEXT */)\n  ]))\n}\n')])])]),a("p",[e._v("并且支持手写内联函数：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<div>\n  <span @click="()=>foo()">\n    {{msg}}\n  </span>\n</div>\n')])])]),a("h3",{attrs:{id:"（3）ssr（server-side-render服务端渲染）优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（3）ssr（server-side-render服务端渲染）优化"}},[e._v("#")]),e._v(" （3）SSR（server side render服务端渲染）优化")]),e._v(" "),a("p",[e._v("静态内容会直接当做纯字符串推进一个buffer里去了。")]),e._v(" "),a("p",[a("img",{attrs:{src:s(484),alt:"img"}})]),e._v(" "),a("p",[a("strong",[e._v("即使存在动态绑定，依然尽可能地做成字符串。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('_ssrRenderAttr("id",_ctx.foo)\n')])])]),a("p",[a("img",{attrs:{src:s(485),alt:"img"}})]),e._v(" "),a("p",[e._v("当静态结点数量超过一定阈值时，启用这样一个优化。单独的创建一个div，将其设置成innerHTML。")]),e._v(" "),a("p",[a("img",{attrs:{src:s(486),alt:"img"}})]),e._v(" "),a("p",[e._v("比"),a("code",[e._v("React")]),e._v("做成一个"),a("code",[e._v("Virtual Dom")]),e._v(" 再去渲染出来，快上一个量级。服务端渲染的性能，完全不在一个层面上。")]),e._v(" "),a("p",[e._v("整体上，比"),a("code",[e._v("Vue 2.x")]),e._v(" 内存占用少一半以上，总体速度快一倍以上。")]),e._v(" "),a("p",[a("img",{attrs:{src:s(487),alt:"img"}})]),e._v(" "),a("p",[e._v("2.Composition API（组合） 和 Options API的对比")]),e._v(" "),a("p",[e._v("组件小的时候，用不同的Options比如methods、compute、data、props等这样分类比较清晰。大型组件中，大量的Options聚在一起。同一个组件可能有多个逻辑关注点，当使用Options API时，每一个关注点都有自己的Options，如下图每一个颜色代表不同的逻辑关注点之间的代码。当修改一个逻辑关注点时，就要在一个文件不断地切换和寻找。")]),e._v(" "),a("p",[e._v("​                        "),a("img",{attrs:{src:s(488),alt:"img"}})]),e._v(" "),a("p",[e._v("**如要用切分这些逻辑点呢？**有时候，不好切分，如果用minxin又会导致命名空间冲突。")]),e._v(" "),a("p",[a("strong",[e._v("Composition API给了一个很好的机制去解决这样的问题，所有某一个逻辑关注点（功能）相关的代码全都放在一个函数里")]),e._v("，当需要去修改一个功能时，就不再需要在一个文件中跳来跳去。")]),e._v(" "),a("p",[a("img",{attrs:{src:s(489),alt:"img"}})]),e._v(" "),a("p",[e._v("当需要复用的时候，就只需要把这个函数提取出去。然后在另一个组件中引入，这个功能就变得可复用了，"),a("strong",[e._v("Composition API使得组件复用变得更加灵活了。")])]),e._v(" "),a("p",[e._v("另一方面，**Composition API会有更好的类型的支持，**因为都是一些函数，在调用函数时，自然所有的类型就被推导出来了。不像OptionsAPI所有的东西使用this。**同时，Composition API的可压缩性会更好一些。**以上就是Composition API引入的理由。")]),e._v(" "),a("p",[e._v("具体地"),a("strong",[e._v("Composition API如何使用可以同过这个网站")]),e._v("[Vue Composition API](https://juejin.im/editor/posts/Vue Composition API)"),a("strong",[e._v("来学习。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);